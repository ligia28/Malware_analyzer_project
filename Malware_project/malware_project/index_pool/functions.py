import hashlib
import os
import pefile
import time
from index_pool.models import *
import yara

def make_sha(filename):
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    print(filename)
    time.sleep(1)
    f=open(filename,"rb")
    string_file = f.read()
    #string_file_As_bytes=str.encode(string_file)
    hash=hashlib.sha256(string_file).hexdigest();
    print(hash)
    return hash


def get_static_info_from_header(filename):
    mw_sha256 = make_sha(filename)
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    pe_exe = pefile.PE(filename)
    string="";
    string="<b>Magic number: </b>";
    if(hex(pe_exe.DOS_HEADER.e_magic)=='0x5A4D' or hex(pe_exe.DOS_HEADER.e_magic)=='0x4D5A'):
        string+="<span>MZ file.</span>"
    else:
        string+="<span>Unknown file type.</span>"
    string="<br><b>Offset of header: </b>";
    string+="<span>"+str(hex(pe_exe.DOS_HEADER.e_lfanew))+"</span>"

    string="<br><b>Type of file: </b>";
    if(hex(pe_exe.NT_HEADERS.Signature)=='0x4550'):
        string+="<span>PE file (portable executable)</span>"
    elif(hex(pe_exe.NT_HEADERS.Signature)=='0x00004550'):
        string+="<span>PE00 file (portable executable)</span>"

    string+="<br><b>Machine type: </b>"
    if(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x10b'):
        string+="<span>32 bits</span>"
    elif(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x20b'):
        string+="<span>64 bits</span>"

    string+="</br><b>Time Compiled: </b>"
    string+="<span>"+str(pe_exe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])+"</span>"

    string+="<br><b>Number of sections: </b>"
    string+="<span>"+str(hex(pe_exe.FILE_HEADER.NumberOfSections))+"</span>"

    string+="<ul><br><b>Special characteristics:</b>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000020'):
        string+="<li><span>This PE contains executable code.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000040'):
        string+="<li><span>This PE contains initialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000080'):
        string+="<li><span>This PE contains uninitialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x10000000'):
        string+="<li><span>The PE can be shared in memory.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x08000000'):
        string+="<li><span>This PE is not pageable.</span></li>"
    string+="</ul>"

    string+="<br><b>Image Base (should be 0x4000 for PE file, 0x10000000 for DLL): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.ImageBase))+"</span>"

    string+="<br><b>SectionAlignement(position in bytes where sections are loaded in memory, should be greater than File Alignment): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SectionAlignment))+"</span>"

    string+="<br><b>Size of the Image: </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SizeOfImage))+"</span>"


    string+="<br><i>Show dimensions and index of DATA_ENTRYS</i>"
    for iterator in pe_exe.OPTIONAL_HEADER.DATA_DIRECTORY:
        string+="<span>"+iterator.name+"<----> Size: "+str(iterator.Size)+"<----> VirtualAdress: "+str(hex(iterator.VirtualAddress))+"</span><br>";

    mw_Sections_db_Array =[]
    ## imi mai trebe vector pentru fiecare sectiune de secvente de octeti in parte ! !!! SA NU UIT
    ####
    counter=0
    string+="<br><b>Sections: </b>"
    for section in pe_exe.sections:
        section_name=section.Name.decode().rstrip('\x00')
        section_virtual_size = hex(section.Misc_VirtualSize)
        section_virtual_address = hex(section.VirtualAddress)
        section_size_of_raw_data = hex(section.SizeOfRawData)
        section_pointer_raw_Data = hex(section.PointerToRawData)
        section_characteristics = hex(section.Characteristics)
        string+="<ul><span>"+section_name+"</span>"
        string+="<li><span>Virtual size: "+section_virtual_size+"</span></li>"
        string+="<li><span>Virtual Address: "+section_virtual_size+"</span></li>"
        string+="<li><span>SizeOfRawData (Physical size): "+section_size_of_raw_data+"</span></li>"
        string+="<li><span>Pointer To Raw Data(Start pointer of Phisical Data bytes): "+section_pointer_raw_Data+"</span></li>"
        section_characteristics_hex=int(section_characteristics,16)
        section_characteristics_hex=int(section_characteristics_hex)
        if(section_characteristics_hex&0x00000020!=0x00000000):
            string+="<br>span><i>The section contain executable code.</i></span>"
        elif(section_characteristics_hex&0x00000040!=0x00000000):
            string+="<br>span><i>The section contain initialized data.</i></span>"
        elif(section_characteristics_hex&0x00000080!=0x00000000):
            string+="<br>span><i>The section contain unitialized data.</i></span>"


        ##vec_section = pe_exe
        #sec_byte = section[:10]
        sec_byte=pe_exe.sections[counter].get_data()[:]
        section_hash=hashlib.sha256(sec_byte).hexdigest();
        ######mw_sections = Malware_Sections(mw_sha256=mw_sha256,section_name=section_name,section_sha="")
        string+="<li><span>SHA256 of section: "+section_hash+"</span></li>"
        string+="</ul>"
        counter=counter+1;

    string+="<ul><span><b>Show imported DLL: </b></span>"
    for dll_imports in pe_exe.DIRECTORY_ENTRY_IMPORT:
        string+="<li><span>"+dll_imports.dll.decode('utf-8')+"</span></li>"
        string+="<ul>"
        for function_imports in dll_imports.imports:
            string+="<li><span>"+function_imports.name.decode('utf-8')+"</span></li>"
        string+="</ul>"
    string+="</ul>"

    try:
        string+="<ul><span><b>Show exported function:</b></span>"
        for exported_function in pe_exe.DIRECTORY_ENTRY_EXPORT.symbols:
            string+="<li><span>"+exported_function.name.decode('utf-8')+"</span></li>"
        string+="</ul>"
    except:
        string+="<span><b>No export function.</b></span>"
    #print(string)
    #print(len(string))
    return string


def make_and_save_image(pe_filename):
    print("sometyhing...")


def extract_features_and_call_DT(jpg_filename):
    print("something")

def apply_yara_rules(pe_filename):
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+pe_filename
    print(filename)
    string=""
    string+="<div class='yara_div'>"
    string+="<ul><span><b>Yara rules found on binary file:</b></span>"
    try:
        #f_pe=open(filename,"rb")
        yara_rules=abs_path+"/mw_files/yara_rules/"+"rules.yara"
        try:
            print(yara_rules)
            yara_rules = yara.compile(yara_rules)
            yara_match = yara_rules.match(filename)
        except Exception as message:
            print("Path to yara rules not found." + str(message))
        for rule in yara_match:
            print(str(rule))
            string+="<li><span>"+str(rule)+"</span></li>"
        if len(yara_match)==0:
            string+="<li><span>Yara rules not found on binary</span></li>"
    except:
        string+="<li><span>Cannot open the binary file.</span></li>"
    string+="</ul>"
    string+="</div>"

    return string



############### write everything in a log file

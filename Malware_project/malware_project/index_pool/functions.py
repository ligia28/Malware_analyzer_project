import hashlib
import os
import pefile
import time
from index_pool.models import *
import yara
import re
from django.db import IntegrityError
import scipy
import scipy.misc
from PIL import Image
import array
import numpy
import sys
import numpy as np
from scipy import ndimage
from scipy.stats import kurtosis, skew
from scipy.stats import entropy as scipy_entropy
from scipy import ndimage
import csv
from keras.preprocessing.image import img_to_array
from keras.preprocessing.image import array_to_img
from keras.preprocessing.image import load_img
from keras.preprocessing.image import save_img
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report,confusion_matrix
import pandas as pd

def make_sha(filename):
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    time.sleep(1)
    f=open(filename,"rb")
    string_file = f.read()
    #string_file_As_bytes=str.encode(string_file)
    hash=hashlib.sha256(string_file).hexdigest();
    return hash

def get_month(cpy_array):
    month=0
    if cpy_array[1].lower()=="ian":
        month=1
    elif cpy_array[1].lower()=="feb":
        month=2
    elif cpy_array[1].lower()=="mar":
        month=3
    elif cpy_array[1].lower()=="apr":
        month=4
    elif cpy_array[1].lower()=="mai":
        month=5
    elif cpy_array[1].lower()=="jun":
        month=6
    elif cpy_array[1].lower()=="jul":
        month=7
    elif cpy_array[1].lower()=="aug":
        month=8
    elif cpy_array[1].lower()=="sep":
        month=9
    elif cpy_array[1].lower()=="oct":
        month=10
    elif cpy_array[1].lower()=="nov":
        month=11
    elif cpy_array[1].lower()=="dec":
        month=12
    return month

def get_day(cpy_array):
    day=0
    if cpy_array[0].lower()=="mon":
        day=1
    elif cpy_array[0].lower()=="tue":
        day=2
    elif cpy_array[0].lower()=="wed":
        day=3
    elif cpy_array[0].lower()=="thu":
        day=4
    elif cpy_array[0].lower()=="fri":
        day=5
    elif cpy_array[0].lower()=="sat":
        day=6
    elif cpy_array[0].lower()=="sun":
        day=7

    return day



def get_static_info_from_header(filename):
    score = 0
    mw_sha256 = make_sha(filename)
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    pe_exe = pefile.PE(filename)
    string="";
    string="<b>Magic number: </b>";
    if(hex(pe_exe.DOS_HEADER.e_magic)=='0x5A4D' or hex(pe_exe.DOS_HEADER.e_magic)=='0x4D5A'):
        string+="<span>MZ file.</span>"
    else:
        string+="<span>Unknown file type.</span>"
    string="<br><b>Offset of header: </b>";
    string+="<span>"+str(hex(pe_exe.DOS_HEADER.e_lfanew))+"</span>"

    string="<br><b>Type of file: </b>";
    if(hex(pe_exe.NT_HEADERS.Signature)=='0x4550'):
        string+="<span>PE file (portable executable)</span>"
    elif(hex(pe_exe.NT_HEADERS.Signature)=='0x00004550'):
        string+="<span>PE00 file (portable executable)</span>"

    string+="<br><b>Machine type: </b>"
    if(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x10b'):
        string+="<span>32 bits</span>"
    elif(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x20b'):
        string+="<span>64 bits</span>"

    string+="</br><b>Time Compiled: </b>"
    string+="<span>"+str(pe_exe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])+"</span>"
    cpy = pe_exe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1]
    cpy_array=re.findall(r'\S+',cpy)

    if(int(cpy_array[4])<=2018):
        score=score+1;
    month=get_month(cpy_array)
    day=get_day(cpy_array)
    comp_time_Str = str(cpy_array[4])+"-"+str(month)+"-"+str(cpy_array[2])+" "+str(cpy_array[3])
    string+="<br><b>Number of sections: </b>"
    string+="<span>"+str(hex(pe_exe.FILE_HEADER.NumberOfSections))+"</span>"

    string+="<ul><br><b>Special characteristics:</b>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000020'):
        string+="<li><span>This PE contains executable code.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000040'):
        string+="<li><span>This PE contains initialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000080'):
        string+="<li><span>This PE contains uninitialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x10000000'):
        string+="<li><span>The PE can be shared in memory.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x08000000'):
        string+="<li><span>This PE is not pageable.</span></li>"
    string+="</ul>"

    string+="<br><b>Image Base (should be 0x4000 for PE file, 0x10000000 for DLL): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.ImageBase))+"</span>"

    string+="<br><b>SectionAlignement(position in bytes where sections are loaded in memory, should be greater than File Alignment): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SectionAlignment))+"</span>"

    string+="<br><b>Size of the Image: </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SizeOfImage))+"</span>"


    string+="<br><i>Show dimensions and index of DATA_ENTRYS</i>"
    for iterator in pe_exe.OPTIONAL_HEADER.DATA_DIRECTORY:
        string+="<span>"+iterator.name+"<----> Size: "+str(iterator.Size)+"<----> VirtualAdress: "+str(hex(iterator.VirtualAddress))+"</span><br>";

    mw_Sections_db_Array =[]
    ## imi mai trebe vector pentru fiecare sectiune de secvente de octeti in parte ! !!! SA NU UIT
    ####
    counter=0
    string+="<br><b>Sections: </b>"
    for section in pe_exe.sections:
        section_name=section.Name.decode().rstrip('\x00')
        if section_name!=".data" and section_name!=".text" and section_name!=".rdata" and section_name!=".idata" and section_name!=".edata" and section_name!=".rsrc":
            score=score+1
        section_virtual_size = hex(section.Misc_VirtualSize)
        section_virtual_address = hex(section.VirtualAddress)
        section_size_of_raw_data = hex(section.SizeOfRawData)
        section_pointer_raw_Data = hex(section.PointerToRawData)
        section_characteristics = hex(section.Characteristics)
        string+="<ul><span>"+section_name+"</span>"
        string+="<li><span>Virtual size: "+section_virtual_size+"</span></li>"
        string+="<li><span>Virtual Address: "+section_virtual_size+"</span></li>"
        string+="<li><span>SizeOfRawData (Physical size): "+section_size_of_raw_data+"</span></li>"
        string+="<li><span>Pointer To Raw Data(Start pointer of Phisical Data bytes): "+section_pointer_raw_Data+"</span></li>"
        section_characteristics_hex=int(section_characteristics,16)
        section_characteristics_hex=int(section_characteristics_hex)
        if(section_characteristics_hex&0x00000020!=0x00000000):
            string+="<br><span><i>The section contain executable code.</i></span>"
        elif(section_characteristics_hex&0x00000040!=0x00000000):
            string+="<br><span><i>The section contain initialized data.</i></span>"
        elif(section_characteristics_hex&0x00000080!=0x00000000):
            string+="<br><span><i>The section contain unitialized data.</i></span>"


        ##vec_section = pe_exe
        #sec_byte = section[:10]
        sec_byte=pe_exe.sections[counter].get_data()[:]
        section_hash=hashlib.sha256(sec_byte).hexdigest();
        ######mw_sections = Malware_Sections(mw_sha256=mw_sha256,section_name=section_name,section_sha="")
        string+="<li><span>SHA256 of section: "+section_hash+"</span></li>"
        string+="</ul>"
        try:
            sec = Malware_Sections(mw_sha256=mw_sha256,section_name=section_name,section_sha=section_hash)
            sec.save()
        except IntegrityError:
            print("Section already exist in database.")
        counter=counter+1;

    string+="<ul><span><b>Show imported DLL: </b></span>"
    for dll_imports in pe_exe.DIRECTORY_ENTRY_IMPORT:
        string+="<li><span>"+dll_imports.dll.decode('utf-8')+"</span></li>"
        if dll_imports.dll.decode('utf-8').lower()=="kernel32.dll":
            score=score+1
        string+="<ul>"
        for function_imports in dll_imports.imports:
            string+="<li><span>"+function_imports.name.decode('utf-8')+"</span></li>"
        string+="</ul>"
    string+="</ul>"

    try:
        string+="<ul><span><b>Show exported function:</b></span>"
        for exported_function in pe_exe.DIRECTORY_ENTRY_EXPORT.symbols:
            string+="<li><span>"+exported_function.name.decode('utf-8')+"</span></li>"
        string+="</ul>"
    except:
        string+="<span><b>No export function.</b></span>"
    #print(string)
    #print(len(string))
    return string, score, comp_time_Str


def make_and_save_image(pe_filename):
    print("sometyhing...")


def extract_features_and_call_DT(jpg_filename):
    print("something")

def apply_yara_rules(pe_filename):
    score=0
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+pe_filename
    print(filename)
    string=""
    string+="<div class='yara_div'>"
    string+="<ul><span><b>Yara rules found on binary file:</b></span>"
    try:
        #f_pe=open(filename,"rb")
        yara_rules=abs_path+"/mw_files/yara_rules/"+"rules.yara"
        try:
            print(yara_rules)
            yara_rules = yara.compile(yara_rules)
            yara_match = yara_rules.match(filename)
            for rule in yara_match:
                print(str(rule))
                string+="<li><span>"+str(rule)+"</span></li>"
                score=score+1
            if len(yara_match)==0:
                string+="<li><span>Yara rules not found on binary</span></li>"
        except Exception as message:
            print("Path to yara rules not found." + str(message))

    except:
        string+="<li><span>Cannot open the binary file.</span></li>"
    string+="</ul>"
    string+="</div>"

    return string, score

def transform_to_image(pe_filename):
    __all__ = ['fromimage','toimage','imsave','imread','bytescale',
               'imrotate','imresize','imshow','imfilter','radon']
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+pe_filename
    f = open(filename,"rb")
    length = os.path.getsize(filename)
    if length <=10000:
    	width=32;
    if length>10000 and length<=30000:
    	width=64;
    if length>30000 and length<=60000:
    	width = 128;
    if length>60000 and length<=100000:
    	width = 256;
    if length>100000 and length<=200000:
    	width = 384;
    if length>200000 and length<=500000:
    	width = 512;
    if length>500000 and length<=1000000:
    	width = 768;
    if length>1000000 and length<=2000000:
    	width = 1024;
    if length>2000000:
    	width = 2048;
    rem = length%width;
    a=array.array('B');
    a.fromfile(f,length-rem);
    f.close();
    new_width = int(len(a)/width);
    g = numpy.reshape(a,(new_width,width));
    g = numpy.uint8(g);
    f.close()
    Image.fromarray(g).save(abs_path+'/mw_files/mw_images/'+pe_filename+'.png')
    Image.fromarray(g).save('index_pool/static/img1/'+pe_filename+'.png')
    #img_array=array_to_img(g)
    #img_image = save_img(abs_path+'/mw_files/mw_images/'+pe_filename+'.png',img_array,scale=True)
    #scipy.misc.imsave('.png',g);
    #image=scipy.misc.toimage(g, high=255, low=0, cmin=None, cmax=None, pal=None, mode=None, channel_axis=None);
    #image.save(abs_path+'/mw_files/mw_images/'+pe_filename+'.png');
    out_file = open(abs_path+'/mw_files/mw_images/values_mw_image.csv',"w")
    out_file.write("Variance,Skewness,Kurtosis,Entropy\n");
    out_file.write(str(g.var())+","+str(skew(g).mean())+","+str(kurtosis(g).mean())+","+str(scipy_entropy(g, base=256).mean())+"\n");
    out_file.close()

    infodata = pd.read_csv(abs_path+'/mw_files/mw_images/train.csv');

    X = infodata.drop('Class',axis=1);
    y=infodata['Class'];

    var_or = infodata['Variance'];
    sk_or = infodata['Skewness'];
    kur_or = infodata['Kurtosis'];
    en_or = infodata['Entropy'];
    class_or = infodata['Class'];

    print(str(var_or) + str(sk_or) + str(kur_or) + str(en_or)+str(class_or))
    classifier = DecisionTreeClassifier();
    classifier.fit(X,y);


    new_infodata = pd.read_csv(abs_path+'/mw_files/mw_images/values_mw_image.csv');
    y_pred = classifier.predict(new_infodata);


    var=new_infodata['Variance'];
    sk=new_infodata['Skewness'];
    kur=new_infodata['Kurtosis'];
    en=new_infodata['Entropy'];

    print(str(var)+"    "+str(sk)+"   "+str(kur)+"   "+str(en));



    out_file = open(abs_path+'/mw_files/mw_images/train',"a")
    out_file.write(str(g.var())+","+str(skew(g).mean())+","+str(kurtosis(g).mean())+","+str(scipy_entropy(g, base=256).mean())+","+str(y_pred)+"\n");
    out_file.close()

    return "/static/img1/"+pe_filename+'.png',var,sk,kur,en,y_pred





############### write everything in a log file

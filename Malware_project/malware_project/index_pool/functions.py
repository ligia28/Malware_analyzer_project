import hashlib
import os
import pefile
import time
from index_pool.models import *

def make_sha(filename):
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    print(filename)
    time.sleep(1)
    f=open(filename,"rb")
    string_file = f.read()
    #string_file_As_bytes=str.encode(string_file)
    hash=hashlib.sha256(string_file).hexdigest();
    print(hash)
    return hash


def get_static_info_from_header(filename):
    mw_sha256 = make_sha(filename)
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    pe_exe = pefile.PE(filename)
    string="";
    string="<b>Magic number: </b>";
    if(hex(pe_exe.DOS_HEADER.e_magic)=='0x5A4D' or hex(pe_exe.DOS_HEADER.e_magic)=='0x4D5A'):
        string+="<span>MZ file.</span>"
    else:
        string+="<span>Unknown file type.</span>"
    string="<br><b>Offset of header: </b>";
    string+="<span>"+str(hex(pe_exe.DOS_HEADER.e_lfanew))+"</span>"

    string="<br><b>Type of file: </b>";
    if(hex(pe_exe.NT_HEADERS.Signature)=='0x4550'):
        string+="<span>PE file (portable executable)</span>"
    elif(hex(pe_exe.NT_HEADERS.Signature)=='0x00004550'):
        string+="<span>PE00 file (portable executable)</span>"

    string+="<br><b>Machine type: </b>"
    if(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x10b'):
        string+="<span>32 bits</span>"
    elif(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x20b'):
        string+="<span>64 bits</span>"

    string+="</br><b>Time Compiled: </b>"
    string+="<span>"+str(pe_exe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])+"</span>"

    string+="<br><b>Number of sections: </b>"
    string+="<span>"+str(hex(pe_exe.FILE_HEADER.NumberOfSections))+"</span>"

    string+="<ul><br><b>Special characteristics:</b>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000020'):
        string+="<li><span>This PE contains executable code.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000040'):
        string+="<li><span>This PE contains initialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000080'):
        string+="<li><span>This PE contains uninitialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x10000000'):
        string+="<li><span>The PE can be shared in memory.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x08000000'):
        string+="<li><span>This PE is not pageable.</span></li>"
    string+="</ul>"

    string+="<br><b>Image Base (should be 0x4000 for PE file, 0x10000000 for DLL): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.ImageBase))+"</span>"

    string+="<br><b>SectionAlignement(position in bytes where sections are loaded in memory, should be greater than File Alignment): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SectionAlignment))+"</span>"

    string+="<br><b>Size of the Image: </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SizeOfImage))+"</span>"


    string+="<br><i>Show dimensions and index of DATA_ENTRYS</i>"
    for iterator in pe_exe.OPTIONAL_HEADER.DATA_DIRECTORY:
        string+="<span>"+iterator.name+"<----> Size: "+str(iterator.Size)+"<----> VirtualAdress: "+str(hex(iterator.VirtualAddress))+"</span><br>";

    mw_Sections_db_Array =[]
    ## imi mai trebe vector pentru fiecare sectiune de secvente de octeti in parte ! !!! SA NU UIT
    ####

    string+="<br><b>Sections: </b>"
    for section in pe_Exe.sections:
        section_name=section.Name.decode().rstrip('\x00')
        section_virtual_size = hex(section.Misc_VirtualSize)
        section_virtual_address = hex(section.VirtualAddress)
        section_size_of_raw_data = hex(section.SizeOfRawData)
        section_pointer_raw_Data = hex(section.PointerToRawData)
        section_characteristics = hex(section.Characteristics)
        string+="<ul><span>"+section_name+"</span>"
        string+="<li><span>Virtual size: "+section_virtual_size+"</span></li>"
        string+="<li><span>Virtual Address: "+section_virtual_size+"</span></li>"
        string+="<li><span>SizeOfRawData (Physical size): "+section_size_of_raw_data+"</span></li>"
        string+="<li><span>Pointer To Raw Data(Start pointer of Phisical Data bytes): "+section_pointer_raw_Data+"</span></li>"
        if(section_characteristics&0x00000020!=0x00000000):
            string+="<br>span><i>The section contain executable code.</i></span>"
        elif(section_characteristics&0x00000040!=0x00000000):
            string+="<br>span><i>The section contain initialized data.</i></span>"
        elif(section_characteristics&0x00000080!=0x00000000):
            string+="<br>span><i>The section contain unitialized data.</i></span>"

        string+="</ul>"
        ##vec_section = pe_exe
        section_hash=hashlib.sha256(sec_byte).hexdigest();
        mw_sections = Malware_Sections(mw_sha256=mw_sha256,section_name=section_name,section_sha="")
        #string+="<li><span></span></li>"




    return string
#################### TO DO get sections

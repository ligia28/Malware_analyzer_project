import hashlib
import os
import pefile
import time

def make_sha(filename):
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    print(filename)
    time.sleep(1)
    f=open(filename,"rb")
    string_file = f.read()
    #string_file_As_bytes=str.encode(string_file)
    hash=hashlib.sha256(string_file).hexdigest();
    print(hash)
    return hash


def get_static_info_from_header(filename):
    abs_path=os.path.abspath(os.getcwd())
    filename=abs_path+"/mw_files/"+filename
    pe_exe = pefile.PE(filename)
    string="";
    string="<b>Magic number: </b>";
    if(hex(pe_exe.DOS_HEADER.e_magic)=='0x5A4D' or hex(pe_exe.DOS_HEADER.e_magic)=='0x4D5A'):
        string+="<span>MZ file.</span>"
    else:
        string+="<span>Unknown file type.</span>"
    string="<br><b>Offset of header: </b>";
    string+="<span>"+str(hex(pe_exe.DOS_HEADER.e_lfanew))+"</span>"

    string="<br><b>Type of file: </b>";
    if(hex(pe_exe.NT_HEADERS.Signature)=='0x4550'):
        string+="<span>PE file (portable executable)</span>"
    elif(hex(pe_exe.NT_HEADERS.Signature)=='0x00004550'):
        string+="<span>PE00 file (portable executable)</span>"

    string+="<br><b>Machine type: </b>"
    if(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x10b'):
        string+="<span>32 bits</span>"
    elif(hex(pe_exe.OPTIONAL_HEADER.Magic)=='0x20b'):
        string+="<span>64 bits</span>"

    string+="</br><b>Time Compiled: </b>"
    string+="<span>"+str(pe_exe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])+"</span>"

    string+="<br><b>Number of sections: </b>"
    string+="<span>"+str(hex(pe_exe.FILE_HEADER.NumberOfSections))+"</span>"

    string+="<ul><br><b>Special characteristics:</b>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000020'):
        string+="<li><span>This PE contains executable code.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000040'):
        string+="<li><span>This PE contains initialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x00000080'):
        string+="<li><span>This PE contains uninitialized data.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x10000000'):
        string+="<li><span>The PE can be shared in memory.</span></li>"
    if(hex(pe_exe.FILE_HEADER.Characteristics)=='0x08000000'):
        string+="<li><span>This PE is not pageable.</span></li>"
    string+="</ul>"

    string+="<br><b>Image Base (should be 0x4000 for PE file, 0x10000000 for DLL): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.ImageBase))+"</span>"

    string+="<br><b>SectionAlignement(position in bytes where sections are loaded in memory, should be greater than File Alignment): </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SectionAlignment))+"</span>"

    string+="<br><b>Size of the Image: </b>"
    string+="<span>"+str(hex(pe_exe.OPTIONAL_HEADER.SizeOfImage))+"</span>"


    string+="<br><i>Show dimensions and index of DATA_ENTRYS</i>"
    for iterator in pe_exe.OPTIONAL_HEADER.DATA_DIRECTORY:
        string+="<span>"+iterator.name+"<----> Size: "+str(iterator.Size)+"<----> VirtualAdress: "+str(hex(iterator.VirtualAddress))+"</span><br>";

    print(string)
    return string
#################### TO DO get sections
